"""
**File name:**    SimulationDataExtractor.py

**Creation:**     2010/06/10

**References:** Please see the SPIS web site `http://www.spis.org`_ for
more information.

:author:       Julien Forest

:version:      1.0.0

**Versions and anomalies correction :**

+---------+--------------------------------------+----------------------------+
| Version | Author (name, e-mail)                | Corrections/Modifications  |
+---------+--------------------------------------+----------------------------+
| 1.0.0   | Julien Forest                        | Creation                   |
|         | j.forest@artenum.com                 |                            |
+---------+--------------------------------------+----------------------------+

PARIS, 2000-2004, Paris, France, `http://www.artenum.com`_

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

.. _`http://www.artenum.com`: http://www.artenum.com
.. _`http://www.spis.org`: http://www.spis.org
"""
import Modules.SolverInterfaces.SimulationDataExtractor
from Modules.SolverInterfaces.SimulationDataExtractor import SimulationDataExtractor

from Modules.Field.DataField            import DataField
from Modules.Field.DataFieldList        import DataFieldList
from Modules.Field.MeshField            import MeshField
from Modules.Field.MeshFieldList        import MeshFieldList
from Modules.Properties.Material        import Material

class SpisNumSimulationDataExtractor(SimulationDataExtractor):
    """
    Performs the data extraction of a SpisNum simulation model. This class is
    inherited from the SimulationDataExtractor interface. 
    
    Usage: 
        extractor = SpisNumSimulationDataExtractor()
        extractor.setInput(sharedSolver["jytop"].simu)
        extractor.setOutputDataBus(sharedData["AllMeshField"], sharedData["AllDataField"])
        extractor.setDefaultSimulationId()
        extractor.readVolumeData()
        extractor.readSCSurfaceData()
        extractor.readBoundarySurfaceData()
    """
    
    def __init__(self):
        """
        Main constructor
        """
        SimulationDataExtractor.__init__(self)        
        
    def readSimulation(self):
        """
        Read (i.e extract) all types of data generated by the simulation model. (NOT operational yet). 
        """
        self.logger.info("SPIS/NUM: Reading of the results")
    
        ###############################################################
        #   Section of return of output data from nun to ui           #
        ###############################################################
        self.logger.info("Getting the output data")
    
    
    
    def readSCSurfaceData(self, mode = "a"):
        """
        read (i.e extract) the data on the inner boundary surface (i.e spacecraft surface). By default data are appended. 
        """
        
        if mode == "w":
            self.resetDataBus()
        
        ##########################################
        # S/C data                               #
        ##########################################
        self.logger.info("Getting  the spacecraft's surface data")
    
        self.scSurfResults = self.simulationModel.getScSurfResults()
        # self.scSurfResults should now contain a SurfField[]
    
        self.dataIndex = max(self.dataFieldDataList.IdList)
        self.logger.debug("Data Index start Value " + `self.dataIndex`)
        for i in range(len(self.scSurfResults)):
            if self.scSurfResults[i] != None:         #we check if the object exist
                #print self.scSurfResults[i].getName()
                self.dataIndex = self.dataIndex + 1
                surfData = DataField()
                surfData.Id = self.dataIndex
                surfData.Name = self.scSurfResults[i].getName()
                surfData.Type = 'Float (TBC)'
                surfData.Unit = self.scSurfResults[i].getUnit().getLongName()
                surfData.Local = self.scSurfResults[i].getCentring().getAbsDim()
                surfData.LockedValue = 0
                
                #tmpValueList = self.scSurfResults[i].getTable().getValues()
                
                # old fashion deprecated
                # FIX E a optimiser
                #surfData.ValueList = []
                #for elm in tmpValueList:
                #    surfData.ValueList.append(elm)
                #new approach
                #surfData.ValueList = self.scSurfResults[i].getTable().getValues().tolist()
                
                
                #new version 
                try: 
                    vectDim = self.scSurfResults[i].getTable().getVectDim()
                    self.logger.debug("Vector data")
                    surfData.ValueList = []
                    # conversion of each vector into list 
                    for vect in self.scSurfResults[i].getTable().getValues().tolist():
                        surfData.ValueList.append(vect.tolist())
                except: 
                    vectDim = 0
                    self.logger.debug("Scalar data")
                    # direct conversion
                    surfData.ValueList = self.scSurfResults[i].getTable().getValues().tolist()
                
                
                    
                surfData.Category = "outSim" + self.simulationId + "Run" + `self.runId` + "DataOnSC"
                
                if surfData.Local == 0:
                    surfData.MeshFieldId = self.meshFieldDataList.Dic['NodeFlagS_MF'].Id
                    if len(self.meshFieldDataList.Dic['NodeFlagS_MF'].MeshElementIdList) != len(surfData.ValueList):
                       self.logger.warn("ERROR datafield vs meshfield, SC "
                                         + `i` + " "
                                         + `len(self.meshFieldDataList.Dic['NodeFlagS_MF'].MeshElementIdList)` + " "
                                         + `len(surfData.ValueList)` + " "
                                         + `surfData.Local`)
                if surfData.Local == 1:
                    surfData.MeshFieldId = self.meshFieldDataList.Dic['EdgeFlagS_MF'].Id
                    if len(self.meshFieldDataList.Dic['EdgeFlagS_MF'].MeshElementIdList) != len(surfData.ValueList):
                       self.logger.warn("ERROR datafield vs meshfield, SC "
                                         + `i` + " "
                                         + `len(self.meshFieldDataList.Dic['EdgeFlagS_MF'].MeshElementIdList)` + " "
                                         + `len(surfData.ValueList)` + " "
                                         + `surfData.Local`)
                if surfData.Local == 2:
                    surfData.MeshFieldId = self.meshFieldDataList.Dic['SurfFlagS_MF'].Id
                    if len(self.meshFieldDataList.Dic['SurfFlagS_MF'].MeshElementIdList) != len(surfData.ValueList):
                       self.logger.warn("ERROR datafield vs meshfield, SC "
                                         + `i` + " "
                                         + `len(self.meshFieldDataList.Dic['SurfFlagS_MF'].MeshElementIdList)` + " "
                                         + `len(surfData.ValueList)` + " "
                                         + `surfData.Local`)
                self.dataFieldDataList.Add_DataField(surfData)
                self.logger.info(surfData.Name)

    
    def readBoundarySurfaceData(self, mode="a"):
        """
        Recover all external boundary surface data. By default data are appended. 
        """
        
        if mode == "w":
            self.resetDataBus()
        
        ##########################################
        # Boundary surface data                  #
        ##########################################
        self.logger.info("Getting now the boundary surface data")
    
        self.bdSurfResults = self.simulationModel.getBdSurfResults()
        # self.bdSurfResults should now contain a SurfField[]
        #self.logger.info('back from NUM: boundary surface fields = '+self.bdSurfResults)
    
        for i in range(len(self.bdSurfResults)):
            if self.bdSurfResults[i] != None:         #we check if the object exist
                print self.bdSurfResults[i].getName()
                bdsurfData = DataField()
                self.dataIndex = self.dataIndex + 1
                bdsurfData.Id = self.dataIndex
                bdsurfData.Name = self.bdSurfResults[i].getName()
                bdsurfData.Type = 'Float (TBC)'
                bdsurfData.Unit = self.bdSurfResults[i].getUnit().getLongName()
                bdsurfData.Local = self.bdSurfResults[i].getCentring().getAbsDim()
                bdsurfData.LockedValue = 0                                           #TBC
                
                #deprecated 
                #tmpValueList = self.bdSurfResults[i].getTable().getValues()
                #bdsurfData.ValueList = []
                #for elm in tmpValueList:
                #    bdsurfData.ValueList.append(elm)
                
                #new
                bdsurfData.ValueList = self.bdSurfResults[i].getTable().getValues().tolist()
                
                bdsurfData.Category = "outSim" + self.simulationId + "Run" + `self.runId` + "DataOnBd"
                #DataField to MeshField re-connection
                bdsurfData.MeshFieldId = self.meshFieldDataList.Dic['NodeFlagBd_MF'].Id
                if bdsurfData.Local == 0:
                    bdsurfData.MeshFieldId = self.meshFieldDataList.Dic['NodeFlagBd_MF'].Id
                    if len(self.meshFieldDataList.Dic['NodeFlagBd_MF'].MeshElementIdList) != len(bdsurfData.ValueList):
                        self.logger.warn("ERROR datafield vs meshfield, Bd "
                                          + `i` + " "
                                          + `len(self.meshFieldDataList.Dic['NodeFlagBd_MF'].MeshElementIdList)` + " "
                                          + `len(bdsurfData.ValueList)` + " "
                                          + `bdsurfData.Local`)
                if bdsurfData.Local == 1:
                    bdsurfData.MeshFieldId = self.meshFieldDataList.Dic['EdgeFlagBd_MF'].Id
                    if len(self.meshFieldDataList.Dic['EdgeFlagBd_MF'].MeshElementIdList) != len(bdsurfData.ValueList):
                        self.logger.warn("ERROR datafield vs meshfield, Bd "
                                          + `i` + " "
                                          + `len(self.meshFieldDataList.Dic['EdgeFlagBd_MF'].MeshElementIdList)` + " "
                                          + `len(bdsurfData.ValueList)` + " "
                                          + `bdsurfData.Local`)
                if bdsurfData.Local == 2:
                    bdsurfData.MeshFieldId = self.meshFieldDataList.Dic['SurfFlagBd_MF'].Id
                    if len(self.meshFieldDataList.Dic['SurfFlagBd_MF'].MeshElementIdList) != len(bdsurfData.ValueList):
                        self.logger.warn("ERROR datafield vs meshfield, Bd  "
                                          + `i` + " "
                                          + `len(self.meshFieldDataList.Dic['SurfFlagBd_MF'].MeshElementIdList)` + " "
                                          + `len(bdsurfData.ValueList)` + " "
                                          + `bdsurfData.Local`) 
                self.dataFieldDataList.Add_DataField(bdsurfData)
                self.logger.info(bdsurfData.Name+" added to data bus")
                
        self.logger.info("Data on external boundary extracted.")
    
    
    def readVolumeData( self, mode="a"):
        """
        read (i.e extract) all data in the computational volume. By default data are appended.
        """
        if mode == "w":
            self.resetDataBus()
               
        ##########################################
        # Volumic data                           #
        ##########################################
        self.logger.info("Getting now the volume data")
    
        self.volResults = self.simulationModel.getVolResults()
        # self.volResults should now contain a VolField[]
        # use .buildExternIndexedTable().getValues() on each of the volField
        #self.logger.info('plasma potential back from NUM' + `self.volResults`)
    
        for i in range(len(self.volResults)):
            if self.volResults[i] != None:         #we check if the object exist
                #print self.volResults[i].getName()
                volData = DataField()
                self.dataIndex = self.dataIndex + 1
                volData.Id = self.dataIndex
                volData.Name = self.volResults[i].getName()
                print "NAME =============>", volData.Name
                volData.Type = 'Float TBC'
                volData.Unit = self.volResults[i].getUnit().getLongName()
                volData.Local = self.volResults[i].getCentring().getAbsDim()
                volData.LockedValue = 0
                                
                #deprecated
                #tmpValueList = self.volResults[i].buildExternIndexedTable().getValues()
                #volData.ValueList = []
                #for elm in tmpValueList:
                #    volData.ValueList.append(elm)
                
                #new version 
                try: 
                    vectDim = self.volResults[i].buildExternIndexedTable().getVectDim()
                    self.logger.debug("Vector data")
                    volData.ValueList = []
                    # conversion of each vector into list 
                    for vect in self.volResults[i].buildExternIndexedTable().getValues().tolist():
                        volData.ValueList.append(vect.tolist())
                except: 
                    vectDim = 0
                    self.logger.debug("Scalar data")
                    # direct conversion
                    volData.ValueList = self.volResults[i].buildExternIndexedTable().getValues().tolist()
                    
                
                volData.Category = "outSim" + self.simulationId + "Run" + `self.runId` + "DataInVolume"
                volData.MeshFieldId = self.meshFieldDataList.Dic['NodeFlag_MF'].Id
                
                if volData.Local == 0:
                    volData.MeshFieldId = self.meshFieldDataList.Dic['NodeFlag_MF'].Id
                    if len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList) != len(volData.ValueList):
                        print "ERROR datafield vs meshfield, Vol ", i, \
                        len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList), \
                        len(volData.ValueList), volData.Local
                if volData.Local == 1:
                    volData.MeshFieldId = self.meshFieldDataList.Dic['EdgeFlag_MF'].Id
                    if len(self.meshFieldDataList.Dic['EdgeFlag_MF'].MeshElementIdList) != len(volData.ValueList):
                        print "ERROR datafield vs meshfield, Vol ", i, \
                        len(self.meshFieldDataList.Dic['EdgeFlag_MF'].MeshElementIdList), \
                        len(volData.ValueList), volData.Local
                if volData.Local == 2:
                    volData.MeshFieldId = self.meshFieldDataList.Dic['SurfFlagBd_MF'].Id
                    if len(self.meshFieldDataList.Dic['SurfFlagBd_MF'].MeshElementIdList) != len(volData.ValueList):
                        print "ERROR datafield vs meshfield, Vol  ", i, \
                        len(self.meshFieldDataList.Dic['SurfFlag_MF'].MeshElementIdList), \
                        len(volData.ValueList), volData.Local
                if volData.Local == 3:
                    volData.MeshFieldId = self.meshFieldDataList.Dic['VolInteracFlag_MF'].Id
                    if len(self.meshFieldDataList.Dic['VolInteracFlag_MF'].MeshElementIdList) != len(volData.ValueList):
                        print "ERROR datafield vs meshfield, Vol  ", i, \
                        len(self.meshFieldDataList.Dic['VolInteracFlag_MF'].MeshElementIdList), \
                        len(volData.ValueList), volData.Local
              
                self.dataFieldDataList.Add_DataField(volData)
                self.logger.info(volData.Name)
    
    
    def readTimeDependentData(self, mode = "a"):
        """
        read the time series based data (e.g. Phi_SC(t) ). By default data are appended.
        """
                
        if mode == "w":
            self.resetDataBus()
            
            
        ##########################################
        # Time dependent data                    #
        ##########################################
        self.logger.info("Getting now the x(t) data")
    
        fieldIndex = max(self.meshFieldDataList.IdList)
        fieldIndex = fieldIndex + 1
        self.logger.info("New MeshFields start at:" + `fieldIndex`)
        
        self.scalTimePlots = self.simulationModel.getScalTimePlots()
        # self.scalTimePlots should now contain a XyData[]
        #self.logger.info('back from NUM: x(t) data  = '+self.scalTimePlots)
        
        # TBC
        #sharedData["scalTimePlots"] = self.scalTimePlots
        
        for i in range(len(self.scalTimePlots)):
            if self.scalTimePlots[i] != None:         #we check if the object exist
                
                nbValideData = self.scalTimePlots[i].getDataNb()
    
                #first, we build the MesField corresponding to the time. Welcome into the hyper-space !
                # For now, time is expressed in number of time step only.
                # for the moment, we build a MeshField for each time-plot and we store directly the
                # the time. But this should be changed into a "time-mesh" in the future
                #self.indexedTime = [i for i in range(len(self.scalTimePlots[0].YArray))]
                self.timeMeshField = MeshField()
                self.timeMeshField.Id = fieldIndex
                self.timeMeshField.Name = 'Time'
                self.timeMeshField.Local = 4
                self.timeMeshField.Description = "time in steps"
                
                tmpArray = range(nbValideData)         
                for j in xrange(nbValideData):
                    tmpArray[j] = self.scalTimePlots[i].XArray[j]
                    
                self.timeMeshField.MeshElementList = tmpArray
                self.timeMeshField.MeshElementIdList = tmpArray    #this is not clean but...
                
                self.meshFieldDataList.Add_MeshField(self.timeMeshField)
    
                self.timeDat = DataField()
                tmpArray = range(nbValideData)
                tmpIdArray = range(nbValideData)
                for j in xrange(nbValideData):
                    tmpArray[j] = self.scalTimePlots[i].YArray[j]
                    tmpIdArray[j] = j
                
                self.dataIndex = self.dataIndex + 1
                self.timeDat.Id = self.dataIndex
                self.timeDat.Name = self.scalTimePlots[i].getName()
                self.timeDat.Type = "FLOAT" #tmpArray[1]
                self.timeDat.Unit = self.scalTimePlots[i].getYTable().getUnit().getLongName()
                self.timeDat.Local = 4                      #time is a curviline x-axis 
                self.timeDat.LockedValue = 0
                self.timeDat.ValueList = tmpArray
                self.timeDat.MeshElementIdList = tmpIdArray
                self.timeDat.MeshFieldId = fieldIndex
                self.timeDat.Category = "outSim" + self.simulationId + "Run" + `self.runId` + "TimeDependentData"
                # XXX see SC section for extension to properties living on edge and surf XXX
                #if len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList) != len(self.volDat.ValueList):
                #    print "ERROR datafield vs meshfield, Vol",i\
                #    ,len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList),len(self.volDat.ValueList)
                self.dataFieldDataList.Add_DataField(self.timeDat)
                self.logger.info(self.timeDat.Name)
                
                fieldIndex = fieldIndex + 1
    
        self.logger.info("Getting now the (x(y))(t) data")
    
        self.curveTimePlots = self.simulationModel.getCurveTimePlots()
        # self.curveTimePlots should now contain a XyzData[]
        # self.logger.info('back from NUM: (x(y))(t) data  = ' + self.curveTimePlots)
    
    
    def readParticleTrajectories(self, mode="a"):
        """
        read (i.e extract) the trajectories of test particles. By default data are appended.
        """
        if mode == "w":
            self.resetDataBus()
        
        ##########################################
        # Particle trajectories                  #
        ##########################################
        self.logger.info("Getting now the trajectory data")
    
        self.trajectories = self.simulationModel.getTrajectories()
        
        # self.trajectories should now contain a Trajectory[]
        
        fieldIndex = max(self.meshFieldDataList.IdList)
        fieldIndex = fieldIndex + 1
        self.logger.info("New MeshFields start at:" + `fieldIndex`)
    
        #TBC
        #sharedData["particleTrajectories"] = self.trajectories
        
        for i in range(len(self.trajectories)):
            if self.trajectories[i] != None:         #we check if the object exist
    
                nbPoints = self.trajectories[i].getPointNb()
                #first, we build the MesField corresponding to the traj. 
                #self.indexedTime = [i for i in range(len(self.scalTimePlots[0].YArray))]
                self.trajMeshField = MeshField()
                self.trajMeshField.Id = fieldIndex
                self.trajMeshField.Name = 'trajectory'
                self.trajMeshField.Local = 5
                self.trajMeshField.Description = "coordinates"
                
                #tmpArray = self.scalTimePlots[i].XArray
                tmpArray = range(nbPoints)
                for j in xrange(nbPoints):
                    tmpArray[j] = (self.trajectories[i].getPosArray()[j][0], self.trajectories[i].getPosArray()[j][1], self.trajectories[i].getPosArray()[j][2])
                    
                self.trajMeshField.MeshElementList = tmpArray  #self.indexedTime
                self.meshFieldDataList.Add_MeshField(self.trajMeshField)
    
                self.velocity = DataField()
                
                #tmpArray = self.scalTimePlots[i].YArray
                tmpArray = range(nbPoints)
                tmpIdArray = range(nbPoints)
                for j in xrange(nbPoints):
                    tmpArray[j] = (self.trajectories[i].getPosArray()[j][0], self.trajectories[i].getPosArray()[j][1], self.trajectories[i].getPosArray()[j][2])
                    tmpIdArray[j] = j
                self.dataIndex = self.dataIndex + 1
                self.velocity.Id = self.dataIndex
                self.velocity.Name = self.trajectories[i].getName()
                self.velocity.Type = "FLOAT" #tmpArray[1]
                self.velocity.Unit = 'see name'
                self.velocity.Local = 5
                self.velocity.LockedValue = 0
                self.velocity.ValueList = tmpArray
                self.velocity.MeshElementIdList = tmpIdArray
                self.velocity.MeshFieldId = fieldIndex
                self.velocity.Category = "outSim" + self.simulationId + "Run" + `self.runId` + "ParticleTrajectory"
                # XXX see SC section for extension to properties living on edge and surf XXX
                #if len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList) != len(self.volDat.ValueList):
                #    print "ERROR datafield vs meshfield, Vol",i\
                #    ,len(self.meshFieldDataList.Dic['NodeFlag_MF'].MeshElementIdList),len(self.volDat.ValueList)
                self.dataFieldDataList.Add_DataField(self.velocity)
                #print self.velocity.Name
                #print >> self.stream, self.velocity.Name
                #print >> self.stream, self.velocity.ValueList
                #print >> self.stream, "\n"
    
                fieldIndex = fieldIndex + 1
        
        self.logger.info('back from NUM: trajectory data  = ' + `self.trajectories`)
    
    
        ####### END OF THE DATA EXTRACTION ########
    
        # more generally for a field f (a SurfField or VolField, as
        # self.top.getScPotential() here):
        # - f.getTable().getValues() returns the values (float[]
        #   or float[][] for a VectxxxField)
        # - for node-centred volume fields, which have a different
        # internal indexing, one must use
        #   f.buildExternIndexedTable().getValues() (f.getTable().getValues() returns scrambled values)
        # - the centring of the field can be tested through
        #   self.top.getScPotential().getCentring().getAbsDim(),
        #   which returns 0 for nodes, 2 for surfaces...
        # - the mesh this field lives on is obtained by
        #   - f.getSm() for a SurfField (must be either
        #   self.bdSurfMesh or self.scSurfMesh)
        #   - f.getVm() for a VolField (must be self.volMesh)
        #   NB: a generic method f.getMesh() might be written in java,
        #   if good for jython
        #   NB2: the meshes are nor duplicated in java, hence testing
        #   whether f.getSm() is self.bdSurfMesh or self.scSurfMesh,
        #   can in principle be done by comparing references
        
